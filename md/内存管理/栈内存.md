<!--
 * @Author: matiastang
 * @Date: 2022-04-22 16:47:14
 * @LastEditors: matiastang
 * @LastEditTime: 2022-04-22 16:59:26
 * @FilePath: /matias-Golang/md/内存管理/栈内存.md
 * @Description: 
-->
# 栈内存

## 寄存器

`寄存器`是中央处理器（CPU）中的稀缺资源，它的存储能力非常有限，但是能提供最快的读写速度，充分利用寄存器的速度可以构建高性能的应用程序。寄存器在物理机上非常有限，然而栈区的操作会使用到两个以上的寄存器，这足以说明栈内存在应用程序的重要性。

`栈寄存器是` CPU 寄存器中的一种，它的主要作用是跟踪函数的调用栈2，Go 语言的汇编代码包含 `BP` 和 `SP` 两个栈寄存器，它们分别存储了栈的`基址指针`和`栈顶的地址`，栈内存与函数调用的关系非常紧密，我们在函数调用一节中曾经介绍过栈区，`BP 和 SP 之间的内存就是当前函数的调用栈`。



## 逃逸分析

在编译器优化中，逃逸分析是用来决定指针动态作用域的方法5。**Go 语言的编译器使用`逃逸分析`决定哪些变量应该在栈上分配，哪些变量应该在堆上分配**，其中包括使用 new、make 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：

1. 指向栈对象的指针不能存在于堆中；
2. 指向栈对象的指针不能在栈对象回收后存活；

## 分段栈

分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：

1. 如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为`热分裂问题`（Hot split）；
2. 一旦 Goroutine 使用的内存越过了分段栈的扩缩容阈值，运行时会触发栈的扩容和缩容，带来额外的工作量；

## 连续栈

连续栈可以解决分段栈中存在的两个问题，其核心原理是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新栈中，新的局部变量或者函数调用就有充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：

1. 在内存空间中分配更大的栈内存空间；
2. 将旧栈中的所有内容复制到新栈中；
3. 将指向旧栈对应变量的指针重新指向新栈；
4. 销毁并回收旧栈的内存空间；

在扩容的过程中，最重要的是调整指针的第三步，这一步能够保证指向栈的指针的正确性，因为栈中的所有变量内存都会发生变化，所以原本指向栈中变量的指针也需要调整。我们在前面提到过经过逃逸分析的 Go 语言程序的遵循以下不变性 —— 指向栈对象的指针不能存在于堆中，所以指向栈中变量的指针只能在栈上，我们只需要调整栈中的所有变量就可以保证内存的安全了。