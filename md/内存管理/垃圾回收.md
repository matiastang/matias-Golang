<!--
 * @Author: matiastang
 * @Date: 2022-04-21 14:29:27
 * @LastEditors: matiastang
 * @LastEditTime: 2022-04-21 15:05:43
 * @FilePath: /matias-Golang/md/内存管理/垃圾回收.md
 * @Description: 垃圾回收
-->
# 垃圾回收

[go 垃圾收集机制](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)

在几乎所有的现代编程语言中，垃圾收集器都是一个复杂的系统，为了在不影响用户程序的情况下回收废弃的内存需要付出非常多的努力，Java 的垃圾收集机制是一个很好的例子，Java 8 中包含`线性`、`并发`、`并行`标记清除和 `G1` 四个垃圾收集器，想要理解它们的工作原理和实现细节需要花费很多的精力。

今天的编程语言通常会使用`手动`和`自动`两种方式管理内存，`C`、`C++` 以及 `Rust` 等编程语言使用`手动`的方式管理内存，工程师需要主动申请或者释放内存；而 `Python`、`Ruby`、`Java` 和 `Go` 等语言使用`自动`的内存管理系统，一般都是**垃圾收集机制**，不过 `Objective-C`、`Swift` 却选择了`手动引用计数（MRC）`,`自动引用计数(ARC)`，虽然引用计数也是自动的内存管理机制，但是我们在这里不会详细介绍它，本节的重点还是垃圾收集。

## 手动内存管理

## 自动内存管理

### 垃圾收集机制

#### 标记清除

`标记清除（Mark-Sweep）`算法是最常见的垃圾收集算法，标记清除收集器是`跟踪式垃圾收集器`，其执行过程可以分成`标记（Mark）`和`清除（Sweep）`两个阶段：

1. 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
2. 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；

最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，**用户程序在垃圾收集的过程中也不能执行**，我们需要用到更复杂的机制来解决 STW 的问题。

#### 三色抽象

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类4：

* 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
* 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

* 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
* 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
* 重复上述两个步骤直到对象图中不存在灰色对象；
当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：

**因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW**



### 引用计数

#### 手动引用计数（MRC）

#### 自动引用计数（ARC）

