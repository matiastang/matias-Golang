<!--
 * @Author: matiastang
 * @Date: 2022-04-21 14:29:27
 * @LastEditors: matiastang
 * @LastEditTime: 2022-04-22 16:40:11
 * @FilePath: /matias-Golang/md/内存管理/垃圾回收.md
 * @Description: 垃圾回收
-->
# 垃圾回收

[go 垃圾收集机制](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/)

在几乎所有的现代编程语言中，垃圾收集器都是一个复杂的系统，为了在不影响用户程序的情况下回收废弃的内存需要付出非常多的努力，Java 的垃圾收集机制是一个很好的例子，Java 8 中包含`线性`、`并发`、`并行`标记清除和 `G1` 四个垃圾收集器，想要理解它们的工作原理和实现细节需要花费很多的精力。

今天的编程语言通常会使用`手动`和`自动`两种方式管理内存，`C`、`C++` 以及 `Rust` 等编程语言使用`手动`的方式管理内存，工程师需要主动申请或者释放内存；而 `Python`、`Ruby`、`Java` 和 `Go` 等语言使用`自动`的内存管理系统，一般都是**垃圾收集机制**，不过 `Objective-C`、`Swift` 却选择了`手动引用计数（MRC）`,`自动引用计数(ARC)`，虽然引用计数也是自动的内存管理机制，但是我们在这里不会详细介绍它，本节的重点还是垃圾收集。

## 手动内存管理

## 自动内存管理

### 垃圾收集机制

#### 标记清除

`标记清除（Mark-Sweep）`算法是最常见的垃圾收集算法，标记清除收集器是`跟踪式垃圾收集器`，其执行过程可以分成`标记（Mark）`和`清除（Sweep）`两个阶段：

1. 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
2. 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表；

最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，**用户程序在垃圾收集的过程中也不能执行**，我们需要用到更复杂的机制来解决 STW 的问题。

#### 三色抽象

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类4：

* 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
* 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

* 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
* 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
* 重复上述两个步骤直到对象图中不存在灰色对象；
当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：

**因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW**

#### 屏障

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作

`Go` 语言中使用的两种写屏障技术，分别是 `Dijkstra` 提出的`插入写屏障`和 `Yuasa` 提出的`删除写屏障`，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。

##### 插入写屏障

Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将有存活可能的对象都标记成灰色以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。

##### 删除写屏障

Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）

远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：

* 增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；
* 并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；
  
因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用`屏障技术`保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。

#### 增量收集器

增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：

需要注意的是，`增量式的垃圾收集`需要与`三色标记法`一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前`打开写屏障`，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。

#### 并发收集器

并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响

虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。

### 引用计数

#### 手动引用计数（MRC）

#### 自动引用计数（ARC）

## GO 垃圾回收演变

v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；
v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段11；
v1.3 — 运行时基于只有指针类型的值包含指针的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集12；
将 unsafe.Pointer 类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；
v1.5 — 实现了基于三色标记清扫的并发垃圾收集器13；
大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下；
计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程；
v1.6 — 实现了去中心化的垃圾收集协调器；
基于显式的状态机使得任意 Goroutine 都能触发垃圾收集的状态迁移；
使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的 CPU 占用14；
v1.7 — 通过并行栈收缩将垃圾收集的时间缩短至 2ms 以内15；
v1.8 — 使用混合写屏障将垃圾收集的时间缩短至 0.5ms 以内16；
v1.9 — 彻底移除暂停程序的重新扫描栈的过程17；
v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标18；
v1.12 — 使用新的标记终止算法简化垃圾收集器的几个阶段19；
v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题20；
v1.14 — 使用全新的页分配器优化内存分配的速度21；

Go 语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作

1. 清理终止阶段；
暂停程序，所有的处理器在这时会进入安全点（Safe point）；
如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
清理处理器上的线程缓存；
4. 清理阶段；
将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
恢复用户程序，所有新创建的对象会标记成白色；
后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；
运行时虽然只会使用 _GCoff、_GCmark 和 _GCmarktermination 三个状态表示垃圾收集的全部阶段，但是在实现上却复杂很多，本节将按照垃圾收集的不同阶段详细分析其实现原理。

垃圾收集是一门非常古老的技术，它的执行速度和利用率很大程度上决定了程序的运行速度，`Go` 语言为了实现`高性能`的`并发垃圾收集器`，使用`三色抽象`、`并发增量回收`、`混合写屏障`、`调步算法`以及用户程序协助等机制将垃圾收集的暂停时间优化至`毫秒级`以下，从早期的版本看到今天，我们能体会到其中的工程设计和演进，作者觉得研究垃圾收集的是实现原理还是非常值得的。