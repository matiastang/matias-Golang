<!--
 * @Author: matiastang
 * @Date: 2022-04-24 09:46:56
 * @LastEditors: matiastang
 * @LastEditTime: 2022-04-24 10:34:10
 * @FilePath: /matias-Golang/md/并发/Channel.md
 * @Description: Channel
-->
# Channel

Go 语言中最常见的、也是经常被人提及的设计模式就是：**不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存**。在很多主流的编程语言中，多个线程传递数据的方式一般都是`共享内存`，为了解决线程竞争，我们需要限制同一时间能够读写这些变量的线程数量，然而这与 Go 语言鼓励的设计并不相同。

虽然我们在 Go 语言中也能使用`共享内存加互斥锁`进行通信，但是 Go 语言提供了一种不同的并发模型，即`通信顺序进程（Communicating sequential processes，CSP）`。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据。

Channel 分成了以下三种类型8：

* 同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；
* 异步 Channel — 基于环形缓存的传统生产者消费者模型；
* chan struct{} 类型的异步 Channel — struct{} 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；

这个提案的目的也不是实现完全无锁的队列，只是在一些关键路径上通过无锁提升 Channel 的性能。社区中已经有无锁 Channel 的实现9，但是在实际的基准测试中，无锁队列在多核测试中的表现还需要进一步的改进

Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。

* 单线程调度器 · 0.x
只包含 40 多行代码；
程序中只能存在一个活跃线程，由 G-M 模型组成；
* 多线程调度器 · 1.0
允许运行多线程的程序；
全局锁导致竞争严重；
* 任务窃取调度器 · 1.1
引入了处理器 P，构成了目前的 G-M-P 模型；
在处理器 P 的基础上实现了基于工作窃取的调度器；
在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题；
时间过长的垃圾回收（Stop-the-world，STW）会导致程序长时间无法工作；
* 抢占式调度器 · 1.2 ~ 至今
1. 基于协作的抢占式调度器 - 1.2 ~ 1.13
通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；
Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停；
2. 基于信号的抢占式调度器 - 1.14 ~ 至今
实现基于信号的真抢占式调度；
垃圾回收在扫描栈时会触发抢占调度；
抢占的时间点不够多，还不能覆盖全部的边缘情况；
* 非均匀存储访问调度器 · 提案
对运行时的各种资源进行分区；
实现非常复杂，到今天还没有提上日程；